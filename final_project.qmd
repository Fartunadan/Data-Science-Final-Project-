---
title: "Final Project"
author: "Fartun, Daija, and Kaela"
format: html
embed-resources: true
execute:
  warning: false
  message: false
editor: visual
---

# Predicting Rent Burden in Florida

## Model Creation

**Read in the cleaned ACS data**

```{r}
library(tidyverse)
library(tidymodels)
library(rpart.plot)
library(vip)
library(haven)

acs_florida <- read_csv("data/acs_florida.csv")

acs_florida <- acs_florida |>
  mutate(across(c(rent_burden, hhtype, cbhhtype, countyfip, metro, city, marst), ~ factor(.x, ordered = FALSE)),
         educd = factor(educd, ordered = TRUE),
         hhwt = frequency_weights(hhwt),
         rent_burdend = factor(rent_burdend, levels = c("severely rent burdened", "rent burdened", "not rent burdened"), ordered = TRUE))
```

**Split the data into training and testing sets**

```{r}
set.seed(30061825)

florida_split <- initial_split(data = acs_florida, prop = 0.75)

florida_train <- training(x = florida_split)
florida_test <- testing(x = florida_split)

```

**Data Exploration - Training Data**

```{r}

florida_train |>
  count(rent_burdend) |>
  ggplot(aes(x = rent_burdend, y = n, fill = rent_burdend)) +
  geom_col() +
  labs(
    title = "Distribution of Rent Burden Among Florida Renter Households",
    x = "Rent Burden Category",
    y = "Number of Households"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

The bar chart shows the distribution of rent burden categories among Florida renter households in the training data set. The largest group consists of households that are not rent burdened, indicating that a substantial portion of renters spend less than 30% of their income on housing. However, a considerable number of households fall into the rent burdened and extremely rent burdened categories, with the extremely rent burdened group slightly larger than the rent burdened group. This distribution highlights that housing affordability is a significant issue for many renters in Florida and suggests a meaningful class imbalance that should be considered when modeling rent burden outcomes.

```{r}
florida_train |>
  ggplot(aes(x = mean_age, fill = factor(rent_burden))) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("0" = "lightblue", "1" = "plum"),
                    labels = c("0" = "not rent burdened", "1" = "rent burdened")) +
  labs(title = "Age Distribution: Rent-Burdened vs Non-Rent-Burdened (Density)",
       x = "Mean Household Age",
       y = "Density",
       fill = "Status") +
  theme_minimal()
```

This density plot shows the distribution of mean household age among rent-burdened and non-rent-burdened households in Florida, 2023. Both distributions are right skewed with peaks in around age 25 and later between ages 60 and 70. We see a high concentration of younger households in the rental market and proportional overlap between the curves across all ages, suggesting that age alone does not differentiate between those households that are rent-burdened and those that are not. There is a notable difference between the second peaks of the two curves, where rent-burdened households are more concentrated around the age of 65 than non-rent burdened households. This aligns with expectations given the older demographic of Florida retirees that rely on fixed income.Â 

Overall, the density curves reveal that rent-burdened and not rent-burdened households follow similar age distributions, suggesting age alone does not differentiate between rent-burdened and not.

**Set up vfolds for cross validation**

```{r}
florida_folds <- vfold_cv(data = florida_train, v = 5, repeats = 1)
```

**Create a recipe for each outcome variable**

```{r}
dummy_rec <- recipe(rent_burden ~ ., data = florida_train) |>
  step_rm(rent_burdend) |>
  step_dummy(all_nominal_predictors()) |>
  step_nzv(all_predictors()) |>
  step_normalize(all_numeric_predictors()) |>
  step_corr(all_integer_predictors())

factor_rec <- recipe(rent_burdend ~ ., data = florida_train) |>
  step_rm(rent_burden) |>
  step_dummy(all_nominal_predictors()) |>
  step_nzv(all_predictors()) |>
  step_normalize(all_numeric_predictors()) |>
  step_corr(all_integer_predictors())

```

### Model 1: Decision Tree with dummy variable

```{r}
# create model, tuning cost complexity, tree depth, and min n 
dummy_mod <-
  decision_tree(
    cost_complexity = tune(),
    tree_depth = tune(),
    min_n = tune()
  ) |>
  set_engine(engine = "rpart") |>
  set_mode(mode = "classification")  
  
# create tuning grid for hyperparameters 
florida_grid <- grid_regular(
  cost_complexity(range = c(-5, -1)), 
  tree_depth(range = c(3, 15)), 
  min_n(),
  levels = 5
  )
  
# create workflow 
dummy_wf <- workflow() |>
  add_recipe(dummy_rec) |>
  add_model(dummy_mod) |>
  add_case_weights(hhwt)

#set up resamples 
dummy_res <-
  dummy_wf |>
  tune_grid(resamples = florida_folds,
            grid = florida_grid,
            metrics = metric_set(accuracy, precision))

dummy_best <- dummy_res |>
  select_best(metric = "precision")

dummy_best
```

```{r}
dummy_final_wf <- 
  dummy_wf |> 
  finalize_workflow(select_best(dummy_res, metric = "precision"))

dummy_fit <- fit(dummy_final_wf, data = florida_train)

# create a tree
rpart.plot::rpart.plot(x = dummy_fit$fit$fit$fit)
```

```{r}
dummy_predictions <- bind_cols(
  florida_train,
  predict(object = dummy_fit, new_data = florida_train),
  predict(object = dummy_fit, new_data = florida_train, type = "prob")
)

conf_mat(data = dummy_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)

accuracy(data = dummy_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)

precision(data = dummy_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)

```

### Model 2: Decision tree with factor variable

```{r}
# create model, tuning cost complexity, tree depth, and min n 

factor_dt_mod <-
  decision_tree(
    cost_complexity = tune(),
    tree_depth = tune(),
    min_n = tune()
  ) |>
  set_engine(engine = "rpart") |>
  set_mode(mode = "classification")

# create tuning grid for hyperparameters 
factor_dt_grid <- grid_regular(
  cost_complexity(range = c(-5, -1)), 
  tree_depth(range = c(3, 15)), 
  min_n(),
  levels = 5
)

# create workflow 
factor_dt_workflow <-
  workflow() |>
  add_recipe(factor_rec) |>
  add_model(factor_dt_mod) |>
  add_case_weights(hhwt)
  
#set up resamples 
factor_dt_res <-
  factor_dt_workflow |>
  tune_grid(resamples = florida_folds,
            grid = factor_dt_grid,
            metrics = metric_set(accuracy, precision))

fdt_best <- factor_dt_res |>
  select_best(metric = "precision")

fdt_best
```

```{r}
fdt_final_wf <- 
  factor_dt_workflow |> 
  finalize_workflow(select_best(factor_dt_res, metric = "precision"))

fdt_fit <- fit(fdt_final_wf, data = florida_train)

# create a tree
rpart.plot::rpart.plot(x = fdt_fit$fit$fit$fit)
```

```{r}
# predict the predicted class and the predicted probability of each class

fdt_predictions <- bind_cols(
  florida_train,
  predict(object = fdt_fit, new_data = florida_train),
  predict(object = fdt_fit, new_data = florida_train, type = "prob")
)

conf_mat(data = fdt_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)

accuracy(data = fdt_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)

precision(data = fdt_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)
```

### Model 3: Elastic net with factor variable

```{r}
# created a multinom_regression model to tune the penalty parameter
elastic_net_mod <-multinom_reg(
  penalty = tune(),
  mixture = tune()) |>
   set_mode(mode = "classification") |>
  set_engine("glmnet")

## created a tuning grid for elastic net regularization,
elastic_net_grid <- grid_regular(penalty(), mixture(), levels = 5)
  
# created an elastic net workflow 
elastic_net_wf <- workflow()  |>
  add_recipe(factor_rec)  |>
  add_model(elastic_net_mod) |>
  add_case_weights(hhwt)

# performed hyperparameter tuning using the on your elastic net hyperparameter grid and cross_validation folds

elastic_net_cv <- elastic_net_wf |>
  tune_grid(
    resamples = florida_folds,
    grid = elastic_net_grid,
    metrics = metric_set(accuracy, precision)
  )

# select the best model based on metric
elastic_net_best <- elastic_net_cv |>
  select_best(metric = "precision")

elastic_net_best
```

```{r}
# finalize workflow with  elastic net workflow and the best model 
elastic_net_final <- finalize_workflow(
  elastic_net_wf,
  parameters = elastic_net_best)

# fit the final elastic net model to the full training data 
elastic_net_fit <- elastic_net_final %>%
  fit(data =florida_train) 


# confusion matrix 
elastic_net_predictions <- bind_cols(
  florida_train,
  predict(object = elastic_net_fit, new_data = florida_train),
  predict(object = elastic_net_fit, new_data = florida_train, type = "prob"))

conf_mat(data = elastic_net_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)

 accuracy(data = elastic_net_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)


precision(data = elastic_net_predictions,
         truth = rent_burdend,
         estimate = .pred_class,
         case_weights = hhwt)
```

### Applying the Best Model to Testing Data

```{r}
testing_predictions <- bind_cols(
  florida_test,
  predict(object = dummy_fit, new_data = florida_test))

conf_mat(data = testing_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)

accuracy(data = testing_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)

precision(data = testing_predictions,
         truth = rent_burden,
         estimate = .pred_class,
         case_weights = hhwt)
```

### Exploring Variable Importance

```{r}
dummy_fit |>
extract_fit_parsnip() |>
vip(num_features = 10)

```
